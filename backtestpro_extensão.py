# -*- coding: utf-8 -*-
"""BacktestPro-Extensão.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EsZ6BAga5uw1gYrs7cQH0jwR5RfGQTG0

APLICATIVO DE BACKTEST  (VERSÃO FINAL PARA EXECUTÁVEL)

 - Esta programa foi a atividade final da extensão de programação, ministrada pela professora cordenadora Patrícia Serqueira.

 -Objetivo: Criar programa útil para algum amigo/parente

 -Resumo : Criei um ambiente simulado para backtest que se concentra em utilizar médias moveis e o indicador IFR(indice de força relativa) ou RSI.

 -Os dados são extraidos do yfinance, tendo severas limitações de tamanho da amostra por ser uma base de dados gratuita.

 -O cliente final é meu cunhado, que é um trader experiente e podera fazer rapidas consultas principalmente para operações de maior prazo. Espero que meu gesto de gratidão contribua para ele continuar namorando minha irmã e ela concentre sua raiva feminina nele.
"""

import datetime
import os
import threading
import tkinter as tk
from tkinter import ttk, messagebox, Text, Scrollbar
import sys

"""# Importações de Terceiros




"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import yfinance as yf
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from tkcalendar import DateEntry
import ta
import queue

"""# Importações de Mídia

"""

from PIL import Image, ImageTk, ImageEnhance
import pygame

"""#FUNÇÃO  PARA O EXECUTÁVEL

"""

def resource_path(relative_path):

    try:
        # PyInstaller cria uma pasta temporária e armazena o caminho em _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)

"""1. Classe de Backtest (LÓGICA)"""

class Backtest:
    def __init__(self, df, asset_name, use_ma1=True, use_ma2=True, ma1_period=10, ma2_period=30,
                 use_rsi=False, rsi_period=14, rsi_buy=30, rsi_sell=70,
                 strategy_type='MM', ma_mode='MM_CROSS', output_path='desktop_output'):

        if not isinstance(df, pd.DataFrame) or df.empty: raise ValueError("DataFrame vazio.")
        self.df = df.copy()
        self.asset_name = asset_name
        self.output_path = output_path
        self.use_ma1 = bool(use_ma1);
        self.use_ma2 = bool(use_ma2);
        self.use_rsi = bool(use_rsi)
        self.ma1_period = int(ma1_period);
        self.ma2_period = int(ma2_period)
        self.strategy_type = strategy_type;
        self.ma_mode = ma_mode
        self.rsi_period = int(rsi_period);
        self.rsi_buy = float(rsi_buy);
        self.rsi_sell = float(rsi_sell)

        if self.strategy_type == 'MM':
            if not (self.use_ma1 or self.use_ma2): raise ValueError("Estratégia MM exige pelo menos uma média.")
            if self.ma_mode == 'MM_CROSS':
                if not (self.use_ma1 and self.use_ma2): raise ValueError("Cruzamento exige MM1 e MM2.")
                if self.ma1_period >= self.ma2_period: raise ValueError("MM1 deve ser menor que MM2.")
        elif self.strategy_type == 'RSI':
            if not self.use_rsi: raise ValueError("Estratégia RSI exige IFR habilitado.")
            if self.rsi_period <= 1: raise ValueError("Período RSI deve ser > 1.")
            if not (0 <= self.rsi_buy < self.rsi_sell <= 100): raise ValueError("Parâmetros RSI inválidos.")

        if self.strategy_type == 'MM':
            self.strategy_name = f"{self.asset_name}_MMCross_{self.ma1_period}x{self.ma2_period}" if self.ma_mode == 'MM_CROSS' else f"{self.asset_name}_PrecoXMM"
        else:
            self.strategy_name = f"{self.asset_name}_IFR_{self.rsi_period}"

        os.makedirs(self.output_path, exist_ok=True)
        self.trades = [];
        self.open_trade = {};
        self.stats = {};
        self.df_trades = pd.DataFrame()
        self._prepare_data()

    def _prepare_data(self):
        try:
            if self.use_ma1: self.df['ma1'] = ta.trend.sma_indicator(self.df['Close'], window=self.ma1_period)
            if self.use_ma2: self.df['ma2'] = ta.trend.sma_indicator(self.df['Close'], window=self.ma2_period)

            if self.strategy_type == 'MM':
                self.df.dropna(inplace=True)
                if self.ma_mode == 'MM_CROSS':
                    self.df['signal'] = np.where(self.df['ma1'] > self.df['ma2'], 1, -1)
                elif self.ma_mode == 'PRICE_CROSS':
                    ref = self.df['ma1'] if self.use_ma1 else self.df['ma2']
                    self.df['signal'] = np.where(self.df['Close'] > ref, 1, -1)
                self.df['signal_shift'] = self.df['signal'].shift(1)
                self.df.dropna(inplace=True)

            if self.use_rsi:
                self.df['rsi'] = ta.momentum.rsi(self.df['Close'], window=self.rsi_period)
                self.df.dropna(inplace=True)
                self.df['rsi_shift'] = self.df['rsi'].shift(1)
                self.df.dropna(inplace=True)
        except Exception as e:
            raise Exception(f"[ERRO] Dados: {e}")

    def run(self):
        if self.strategy_type == 'MM':
            return self._run_mm()
        elif self.strategy_type == 'RSI':
            return self._run_rsi()

    def _run_mm(self):
        for i in range(len(self.df)):
            row = self.df.iloc[i]
            if not self.open_trade and row['signal_shift'] == -1 and row['signal'] == 1:
                self.open_trade = {'entry_date': row.name, 'entry_price': row['Open'], 'type': 'long'}
            elif self.open_trade and row['signal_shift'] == 1 and row['signal'] == -1:
                self._close_trade(row)
        self._calculate_stats()
        return f"Backtest (MM) finalizado. {len(self.trades)} trades."

    def _run_rsi(self):
        for i in range(len(self.df)):
            row = self.df.iloc[i]
            if not self.open_trade and row['rsi_shift'] <= self.rsi_buy and row['rsi'] > self.rsi_buy:
                self.open_trade = {'entry_date': row.name, 'entry_price': row['Open'], 'type': 'long'}
            elif self.open_trade and row['rsi_shift'] >= self.rsi_sell and row['rsi'] < self.rsi_sell:
                self._close_trade(row)
        self._calculate_stats()
        return f"Backtest (RSI) finalizado. {len(self.trades)} trades."

    def _close_trade(self, row):
        trade = self.open_trade.copy()
        trade.update({'exit_date': row.name, 'exit_price': row['Open']})
        trade['return_pct'] = (trade['exit_price'] / trade['entry_price']) - 1
        trade['return_abs'] = trade['exit_price'] - trade['entry_price']
        trade['duration'] = trade['exit_date'] - trade['entry_date']
        self.trades.append(trade)
        self.open_trade = {}

    def _calculate_stats(self):
        if not self.trades: self.stats = {'Total de trades': 0}; return
        self.df_trades = pd.DataFrame(self.trades)
        wins = self.df_trades[self.df_trades['return_pct'] > 0]
        losses = self.df_trades[self.df_trades['return_pct'] <= 0]

        self.stats = {
            'Nome da estratégia': self.strategy_name,
            'Total de trades': len(self.df_trades),
            'Trades vencedores': len(wins),
            'Trades perdedores': len(losses),
            'Taxa de acerto': f"{(len(wins) / len(self.df_trades)) * 100:.2f}%",
            'Retorno Total': f"{((self.df_trades['return_pct'] + 1).prod() - 1) * 100:.2f}%",
            'Média Ganho': f"{wins['return_pct'].mean() * 100:.2f}%" if len(wins) > 0 else "0%",
            'Média Perda': f"{losses['return_pct'].mean() * 100:.2f}%" if len(losses) > 0 else "0%"
        }

    def display(self):
        if not self.stats: return ["Nenhuma estatística."], None
        return [f"{k}: {v}" for k, v in self.stats.items()], self.df_trades

    def plot(self):
        if self.df.empty: raise Exception("DataFrame vazio.")
        plt.style.use('dark_background')
        bg_color = '#303030'
        grid_color = '#444444'
        text_color = 'white'

        if self.strategy_type == 'MM':
            fig, ax = plt.subplots(figsize=(12, 7))
            fig.patch.set_facecolor(bg_color);
            ax.set_facecolor(bg_color)
            ax.plot(self.df.index, self.df['Close'], label='Preço', color='white', alpha=0.5, linewidth=1)
            if self.use_ma1: ax.plot(self.df.index, self.df['ma1'], label=f'MM1 ({self.ma1_period})', color='#00e676',
                                     alpha=0.8)
            if self.use_ma2: ax.plot(self.df.index, self.df['ma2'], label=f'MM2 ({self.ma2_period})', color='#ff1744',
                                     alpha=0.8)
            if not self.df_trades.empty:
                for _, t in self.df_trades.iterrows():
                    color = '#00e676' if t['return_pct'] > 0 else '#ff1744'
                    ax.plot([t['entry_date'], t['exit_date']], [t['entry_price'], t['exit_price']], color=color, lw=2,
                            marker='o')
            ax.set_title(f"Backtest: {self.strategy_name}", color=text_color)
            ax.legend(facecolor=bg_color, edgecolor=text_color)
            ax.grid(True, color=grid_color, linestyle='--')
            return fig

        elif self.strategy_type == 'RSI':
            fig, (ax_price, ax_rsi) = plt.subplots(2, 1, figsize=(12, 7), sharex=True,
                                                   gridspec_kw={'height_ratios': [2, 1]})
            fig.patch.set_facecolor(bg_color)
            ax_price.set_facecolor(bg_color)
            ax_price.plot(self.df.index, self.df['Close'], label='Preço', color='white', alpha=0.7)
            if not self.df_trades.empty:
                for _, t in self.df_trades.iterrows():
                    color = '#00e676' if t['return_pct'] > 0 else '#ff1744'
                    ax_price.plot([t['entry_date'], t['exit_date']], [t['entry_price'], t['exit_price']], color=color,
                                  lw=2, marker='o')
            ax_price.grid(True, color=grid_color, linestyle='--')
            ax_rsi.set_facecolor(bg_color)
            ax_rsi.plot(self.df.index, self.df['rsi'], label=f'IFR ({self.rsi_period})', color='#2979ff')
            ax_rsi.axhline(self.rsi_buy, linestyle='--', color='gray', label='Compra')
            ax_rsi.axhline(self.rsi_sell, linestyle='--', color='gray', label='Venda')
            ax_rsi.set_ylim(0, 100)
            ax_rsi.grid(True, color=grid_color, linestyle='--')
            fig.suptitle(f"Backtest: {self.strategy_name}", color=text_color)
            return fig

    def export(self):
        if not self.df_trades.empty:
            path = os.path.join(self.output_path, f"{self.strategy_name}_trades.csv")
            self.df_trades.to_csv(path)
            return f"CSV salvo: {path}"
        return "Sem trades."

2. Interface Gráfica

class BacktestApp(tk.Frame):
    def __init__(self, master=None):
        super().__init__(master)
        self.master = master
        self.master.title("Quant Backtest Pro")
        self.master.geometry("1150x850")
        self.master.minsize(1000, 700)
        self.setup_modern_theme()

        # --- Mídia ---
        self.setup_background_image()
        # USO DO RESOURCE PATH PARA O EXECUTÁVEL
        self.music_file = resource_path("background_music.mp3")
        self.play_background_music()

        self.log_queue = queue.Queue()
        self.backtest_thread = None

        self.after(3500, self.finish_intro_and_show_ui)
        self.after(200, self.process_log_queue)

    def finish_intro_and_show_ui(self):
        self.create_widgets()

    def play_background_music(self):
        try:
            pygame.mixer.init()
            if os.path.exists(self.music_file):
                pygame.mixer.music.load(self.music_file)
                pygame.mixer.music.set_volume(0.3)
                pygame.mixer.music.play(loops=-1)
            else:
                print(f"Música não encontrada em: {self.music_file}")
        except Exception as e:
            print(f"Erro no áudio: {e}")

    def setup_background_image(self):
        # USO DO RESOURCE PATH PARA O EXECUTÁVEL
        img_path = resource_path("header_image.jpg")

        if os.path.exists(img_path):
            try:
                pil_img = Image.open(img_path)
                enhancer = ImageEnhance.Brightness(pil_img)
                pil_img_dark = enhancer.enhance(0.3)
                target_size = (1920, 1080)
                pil_img_resized = pil_img_dark.resize(target_size, Image.Resampling.LANCZOS)
                self.bg_image_tk = ImageTk.PhotoImage(pil_img_resized)
                bg_label = tk.Label(self.master, image=self.bg_image_tk, borderwidth=0)
                bg_label.place(x=0, y=0, relwidth=1, relheight=1)
                bg_label.lower()
            except Exception as e:
                print(f"Erro imagem fundo: {e}")

    def setup_modern_theme(self):
        self.colors = {"bg_main": "#212121", "bg_card": "#303030", "fg_text": "#ffffff", "accent": "#00adb5",
                       "accent_hover": "#00c4cc", "bg_input": "#424242", "fg_input": "#ffffff"}
        style = ttk.Style()
        style.theme_use('clam')
        self.master.configure(background=self.colors["bg_main"])
        style.configure('TFrame', background=self.colors["bg_main"])
        style.configure('Card.TFrame', background=self.colors["bg_card"], relief='flat')
        style.configure('TLabel', background=self.colors["bg_card"], foreground=self.colors["fg_text"],
                        font=('Segoe UI', 10))
        style.configure('TButton', background=self.colors["accent"], foreground=self.colors["bg_main"],
                        font=('Segoe UI', 10, 'bold'), borderwidth=0, padding=(10, 5))
        style.map('TButton', background=[('active', self.colors["accent_hover"])])
        for widget in ['TEntry', 'TSpinbox', 'TCombobox']: style.configure(widget,
                                                                           fieldbackground=self.colors["bg_input"],
                                                                           foreground=self.colors["fg_input"],
                                                                           borderwidth=0, padding=5)
        style.configure('TCheckbutton', background=self.colors["bg_card"], foreground=self.colors["fg_text"],
                        font=('Segoe UI', 10), focuscolor=self.colors["bg_card"])
        style.map('TCheckbutton', background=[('active', self.colors["bg_card"])])
        style.configure('TNotebook', background=self.colors["bg_main"], borderwidth=0)
        style.configure('TNotebook.Tab', background=self.colors["bg_card"], foreground="white", padding=(15, 8),
                        font=('Segoe UI', 10))
        style.map('TNotebook.Tab', background=[('selected', self.colors["accent"])],
                  foreground=[('selected', '#212121')])

    def create_widgets(self):
        main_container = ttk.Frame(self.master)
        main_container.pack(fill=tk.BOTH, expand=True, padx=50, pady=50)
        paned = ttk.PanedWindow(main_container, orient=tk.VERTICAL)
        paned.pack(fill=tk.BOTH, expand=True)

        controls_card = ttk.Frame(paned, style='Card.TFrame', padding=25)
        paned.add(controls_card, weight=0)
        ttk.Label(controls_card, text="PARÂMETROS DE EXECUÇÃO", font=('Segoe UI', 12, 'bold'),
                  foreground=self.colors['accent']).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0, 20))
        controls_card.columnconfigure(1, weight=1);
        controls_card.columnconfigure(3, weight=1)

        ttk.Label(controls_card, text="Ativos (sep. vírgula):").grid(row=1, column=0, sticky='w', pady=5)
        self.assets_var = tk.StringVar(value="PETR4.SA, VALE3.SA")
        ttk.Entry(controls_card, textvariable=self.assets_var).grid(row=1, column=1, columnspan=3, sticky='ew', padx=10)

        ttk.Label(controls_card, text="Início:").grid(row=2, column=0, sticky='w', pady=5)
        self.start_date_var = tk.StringVar(value="01/01/2023")
        self.start_date_entry = DateEntry(controls_card, textvariable=self.start_date_var, date_pattern='dd/MM/yyyy',
                                          width=12, background=self.colors['accent'], foreground='white', borderwidth=0)
        self.start_date_entry.grid(row=2, column=1, sticky='w', padx=10)
        ttk.Label(controls_card, text="Fim:").grid(row=2, column=2, sticky='w', pady=5, padx=(20, 0))
        self.end_date_var = tk.StringVar(value=datetime.date.today().strftime('%d/%m/%Y'))
        self.end_date_entry = DateEntry(controls_card, textvariable=self.end_date_var, date_pattern='dd/MM/yyyy',
                                        width=12, background=self.colors['accent'], foreground='white', borderwidth=0)
        self.end_date_entry.grid(row=2, column=3, sticky='w', padx=10)

        ttk.Label(controls_card, text="Estratégia:").grid(row=3, column=0, sticky='w', pady=15)
        self.strategy_type_var = tk.StringVar(value="Médias Móveis")
        self.strategy_cb = ttk.Combobox(controls_card, textvariable=self.strategy_type_var,
                                        values=["Médias Móveis", "RSI (IFR)"], state="readonly")
        self.strategy_cb.grid(row=3, column=1, sticky='ew', padx=10)
        self.strategy_cb.bind("<<ComboboxSelected>>", self.on_strategy_type_change)
        ttk.Label(controls_card, text="Intervalo:").grid(row=3, column=2, sticky='w', padx=(20, 0))
        self.interval_var = tk.StringVar(value="1d")
        ttk.Combobox(controls_card, textvariable=self.interval_var, values=["1d", "1wk", "1h", "15m"], state="readonly",
                     width=8).grid(row=3, column=3, sticky='w', padx=10)

        settings_frame = ttk.Frame(controls_card, style='Card.TFrame')
        settings_frame.grid(row=4, column=0, columnspan=4, sticky='ew', pady=(10, 0))

        mm_col = ttk.Frame(settings_frame, style='Card.TFrame')
        mm_col.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 10))
        ttk.Label(mm_col, text="Médias Móveis", font=('Segoe UI', 10, 'bold'), foreground=self.colors['accent']).pack(
            anchor='w', pady=(0, 10))
        self.ma1_enabled_var = tk.BooleanVar(value=True)
        f_ma1 = ttk.Frame(mm_col, style='Card.TFrame');
        f_ma1.pack(fill=tk.X, pady=2)
        ttk.Checkbutton(f_ma1, text="MM Rápida:", variable=self.ma1_enabled_var).pack(side=tk.LEFT)
        self.ma1_period_var = tk.IntVar(value=9)
        ttk.Spinbox(f_ma1, from_=1, to=999, textvariable=self.ma1_period_var, width=5).pack(side=tk.RIGHT)
        self.ma2_enabled_var = tk.BooleanVar(value=True)
        f_ma2 = ttk.Frame(mm_col, style='Card.TFrame');
        f_ma2.pack(fill=tk.X, pady=2)
        ttk.Checkbutton(f_ma2, text="MM Lenta:", variable=self.ma2_enabled_var).pack(side=tk.LEFT)
        self.ma2_period_var = tk.IntVar(value=21)
        ttk.Spinbox(f_ma2, from_=1, to=999, textvariable=self.ma2_period_var, width=5).pack(side=tk.RIGHT)
        ttk.Label(mm_col, text="Modo de Operação:").pack(anchor='w', pady=(10, 2))
        self.ma_mode_var = tk.StringVar(value="Cruzamento de 2 MMs")
        self.ma_mode_cb = ttk.Combobox(mm_col, textvariable=self.ma_mode_var,
                                       values=["Cruzamento de 2 MMs", "Cruzamento de preço"], state="readonly")
        self.ma_mode_cb.pack(fill=tk.X)

        ifr_col = ttk.Frame(settings_frame, style='Card.TFrame')
        ifr_col.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(10, 0))
        ttk.Label(ifr_col, text="IFR (RSI)", font=('Segoe UI', 10, 'bold'), foreground=self.colors['accent']).pack(
            anchor='w', pady=(0, 10))
        self.rsi_enabled_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(ifr_col, text="Habilitar Cálculo IFR", variable=self.rsi_enabled_var).pack(anchor='w', pady=2)
        f_rsi_p = ttk.Frame(ifr_col, style='Card.TFrame');
        f_rsi_p.pack(fill=tk.X, pady=2)
        ttk.Label(f_rsi_p, text="Período:").pack(side=tk.LEFT)
        self.rsi_period_var = tk.IntVar(value=14)
        ttk.Spinbox(f_rsi_p, from_=2, to=200, textvariable=self.rsi_period_var, width=5).pack(side=tk.RIGHT)
        f_rsi_b = ttk.Frame(ifr_col, style='Card.TFrame');
        f_rsi_b.pack(fill=tk.X, pady=(10, 2))
        ttk.Label(f_rsi_b, text="Nível Compra:").pack(side=tk.LEFT)
        self.rsi_buy_var = tk.IntVar(value=30)
        ttk.Spinbox(f_rsi_b, from_=1, to=99, textvariable=self.rsi_buy_var, width=5).pack(side=tk.RIGHT)
        f_rsi_s = ttk.Frame(ifr_col, style='Card.TFrame');
        f_rsi_s.pack(fill=tk.X, pady=2)
        ttk.Label(f_rsi_s, text="Nível Venda:").pack(side=tk.LEFT)
        self.rsi_sell_var = tk.IntVar(value=70)
        ttk.Spinbox(f_rsi_s, from_=1, to=99, textvariable=self.rsi_sell_var, width=5).pack(side=tk.RIGHT)

        self.run_button = ttk.Button(controls_card, text="EXECUTAR ANÁLISE", command=self.start_backtest_thread,
                                     style='TButton')
        self.run_button.grid(row=6, column=0, columnspan=4, sticky='ew', pady=(25, 5))

        output_container = ttk.Frame(paned, padding=(0, 25, 0, 0))
        paned.add(output_container, weight=1)
        self.notebook = ttk.Notebook(output_container)
        self.notebook.pack(fill=tk.BOTH, expand=True)

        log_tab = ttk.Frame(self.notebook, style='Card.TFrame', padding=15)
        self.notebook.add(log_tab, text='  LOG DE OPERAÇÕES  ')
        self.log_text = Text(log_tab, wrap=tk.WORD, state=tk.DISABLED, height=10,
                             bg=self.colors['bg_input'], fg='#e0e0e0', insertbackground='white', borderwidth=0,
                             highlightthickness=0, font=('Consolas', 10))
        scroll = ttk.Scrollbar(log_tab, command=self.log_text.yview)
        self.log_text.configure(yscrollcommand=scroll.set)
        self.log_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scroll.pack(side=tk.RIGHT, fill=tk.Y)

        self.plot_tab = ttk.Frame(self.notebook, style='Card.TFrame')
        self.notebook.add(self.plot_tab, text='  VISUALIZAÇÃO GRÁFICA  ')
        self.plot_canvas_frame = ttk.Frame(self.plot_tab, style='Card.TFrame', padding=10)
        self.plot_canvas_frame.pack(fill=tk.BOTH, expand=True)
        self.current_plot_canvas = None

        legend_tab = ttk.Frame(self.notebook, style='Card.TFrame', padding=20)
        self.notebook.add(legend_tab, text='  GLOSSÁRIO  ')
        self.legend_text = Text(legend_tab, wrap=tk.WORD, state=tk.NORMAL, bg=self.colors['bg_card'], fg='#cccccc',
                                borderwidth=0, highlightthickness=0, font=('Segoe UI', 10))
        legend_content = (
            "Nome da estratégia: Identificação da combinação de ativo e parâmetros.\n\n"
            "Total de trades: Número total de operações realizadas.\n\n"
            "Taxa de acerto (%): % de trades vencedores.\n\n"
            "Retorno Total (%): Resultado acumulado no período.\n\n"
            "Média Ganho/Perda: Média percentual das operações."
        )
        self.legend_text.insert(tk.END, legend_content)
        self.legend_text.config(state=tk.DISABLED)
        self.legend_text.pack(fill=tk.BOTH, expand=True)

    def on_strategy_type_change(self, event=None):
        if self.strategy_type_var.get().startswith("RSI"):
            self.ma_mode_var.set("Cruzamento de preço");
            self.ma_mode_cb.config(state='disabled')
        else:
            self.ma_mode_cb.config(state='readonly')

    def log_message(self, msg: str):
        self.log_queue.put(msg)

    def add_plot(self, fig):
        if self.current_plot_canvas: self.current_plot_canvas.get_tk_widget().destroy()
        canvas = FigureCanvasTkAgg(fig, master=self.plot_canvas_frame)
        canvas.draw()
        widget = canvas.get_tk_widget()
        widget.configure(bg=self.colors['bg_card'])
        widget.pack(fill=tk.BOTH, expand=True)
        self.current_plot_canvas = canvas
        self.notebook.select(self.plot_tab)

    def start_backtest_thread(self):
        self.log_text.config(state=tk.NORMAL);
        self.log_text.delete('1.0', tk.END);
        self.log_text.config(state=tk.DISABLED)
        if self.current_plot_canvas: self.current_plot_canvas.get_tk_widget().destroy(); self.current_plot_canvas = None
        self.log_queue.put(("STATUS", "RUNNING"))
        try:
            params = {
                "assets_raw": self.assets_var.get(),
                "start_date": self.start_date_entry.get_date().strftime('%Y-%m-%d'),
                "end_date": self.end_date_entry.get_date().strftime('%Y-%m-%d'),
                "interval": self.interval_var.get(),
                "use_ma1": self.ma1_enabled_var.get(), "use_ma2": self.ma2_enabled_var.get(),
                "ma1_period": self.ma1_period_var.get(), "ma2_period": self.ma2_period_var.get(),
                "strategy_type": "MM" if self.strategy_type_var.get() == "Médias Móveis" else "RSI",
                "ma_mode": "MM_CROSS" if self.ma_mode_var.get() == "Cruzamento de 2 MMs" else "PRICE_CROSS",
                "use_rsi": self.rsi_enabled_var.get(), "rsi_period": self.rsi_period_var.get(),
                "rsi_buy": self.rsi_buy_var.get(), "rsi_sell": self.rsi_sell_var.get()
            }
            if params['strategy_type'] == 'MM' and not (params['use_ma1'] or params['use_ma2']):
                messagebox.showerror("Erro de Validação", "Selecione ao menos uma Média Móvel.");
                self.log_queue.put(("STATUS", "DONE"));
                return
            self.backtest_thread = threading.Thread(target=self.run_backtest_logic, args=(params,))
            self.backtest_thread.daemon = True
            self.backtest_thread.start()
        except Exception as e:
            messagebox.showerror("Erro de Parâmetros", f"Verifique os dados: {e}")
            self.log_queue.put(("STATUS", "DONE"))

    def run_backtest_logic(self, params):
        try:
            self.log_message("--- INICIANDO PROCESSAMENTO ---")
            assets = [a.strip().upper() for a in params['assets_raw'].split(',') if a.strip()]
            self.log_message(f"Baixando: {len(assets)} ativo(s)...")
            data = yf.download(assets, start=params['start_date'], end=params['end_date'], interval=params['interval'],
                               auto_adjust=True, progress=False)
            if data.empty: self.log_message("[ERRO] Sem dados."); self.log_queue.put(("STATUS", "DONE")); return
            if isinstance(data.columns, pd.MultiIndex):
                target = assets[0]
                if target in data.columns.levels[1]:
                    asset_data = data.xs(target, axis=1, level=1)
                else:
                    self.log_message(f"[ERRO] {target} indisponível."); self.log_queue.put(("STATUS", "DONE")); return
            else:
                target = assets[0]; asset_data = data
            self.log_message(f"> Analisando: {target}")
            bt = Backtest(asset_data, target, **{k: v for k, v in params.items() if
                                                 k not in ['assets_raw', 'start_date', 'end_date', 'interval']})
            self.log_message(bt.run())
            stats, _ = bt.display()
            for s in stats: self.log_message(f"  * {s}")
            self.log_queue.put(bt.plot())
            self.log_message(bt.export())
            self.log_message("--- FIM ---")
        except Exception as e:
            self.log_message(f"[ERRO CRÍTICO]: {e}")
        finally:
            self.log_queue.put(("STATUS", "DONE"))

    def process_log_queue(self):
        while not self.log_queue.empty():
            item = self.log_queue.get()
            if isinstance(item, tuple):
                if item[1] == "RUNNING":
                    self.run_button.config(state=tk.DISABLED, text="PROCESSANDO...", style='TButton')
                elif item[1] == "DONE":
                    self.run_button.config(state=tk.NORMAL, text="EXECUTAR ANÁLISE")
            elif isinstance(item, plt.Figure):
                self.add_plot(item)
            else:
                self.log_text.config(state=tk.NORMAL)
                self.log_text.insert(tk.END, f"[{datetime.datetime.now().strftime('%H:%M:%S')}] {item}\n")
                self.log_text.see(tk.END)
                self.log_text.config(state=tk.DISABLED)
        self.after(200, self.process_log_queue)


if __name__ == "__main__":
    if sys.stdout is None: sys.stdout = open(os.devnull, 'w')
    if sys.stderr is None: sys.stderr = open(os.devnull, 'w')
    try:
        from ctypes import windll;

        windll.shcore.SetProcessDpiAwareness(1)
    except:
        pass
    root = tk.Tk()
    app = BacktestApp(master=root)


    def on_close():
        try:
            pygame.mixer.quit()
        except:
            pass
        root.destroy()


    root.protocol("WM_DELETE_WINDOW", on_close)
    root.mainloop()